{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"indentedlogs \u00b6 This library attempts to turn your logs into more readable form by addind indentation to the messages according to their location in the call stack. It also works well in conjunction with coloredlogs . Let's see how these two libraries cooperate. As an example we will use demo.py script. demo.py def bump_version (): pass def configure (): log . debug ( f \"Collecting parameters\" ) log . debug ( f \"Ask for confirmation\" ) log . info ( f \"Save configuration\" ) def select_target (): log . warning ( f \"Default target selected\" ) def prepare (): log . debug ( f \"Bump version\" ) bump_version () log . debug ( f \"Generate configuration\" ) configure () log . debug ( f \"Select target\" ) select_target () def call_compiler (): log . debug ( f \"Preprocess sources\" ) log . info ( f \"Compile sources\" ) def call_linker (): log . info ( f \"Link objects\" ) def build_executable (): # Note that callables that don't invoke logging # don't create additional indentation call_compiler () call_linker () def build_package (): log . warning ( f \"Symbols will be removed\" ) log . debug ( f \"Strip binary\" ) log . debug ( f \"Add meta data\" ) log . debug ( f \"Create archive\" ) def upload_package (): pass def release_app (): log . debug ( f \"Prepare\" ) prepare () log . info ( f \"Build executable\" ) build_executable () log . info ( f \"Build package\" ) build_package () log . info ( f \"Upload package\" ) upload_package () release_app () In order to make the script work, we need to obtain an instance of the logger and apply basic configuration. In the next step we will add indenting and coloring as demonstrated below. Initial Configuration import logging fmt = ' {asctime} {levelname:<8} {filename:>3} : {lineno:<3} {name:>10} {message} ' datefmt = '%Y-%m- %d %H:%M:%S' logging . basicConfig ( level = 'DEBUG' , format = fmt , datefmt = datefmt , style = '{' ) log = logging . getLogger () Indenting Added import logging import indentedlogs fmt = ' {asctime} {levelname:<8} {filename:>3} : {lineno:<3} {name:>10} {message} ' datefmt = '%Y-%m- %d %H:%M:%S' logging . basicConfig ( level = 'DEBUG' , format = fmt , datefmt = datefmt , style = '{' ) indentedlogs . install () log = logging . getLogger () Coloring Added import logging import indentedlogs import coloredlogs fmt = ' {asctime} {levelname:<8} {filename:>3} : {lineno:<3} {name:>10} {message} ' coloredlogs . install ( level = 'DEBUG' , fmt = fmt , style = '{' ) indentedlogs . install () # must be called after coloredlogs log = logging . getLogger () Finally we can run three versions of the script and compare the results. Note that the actual color palette may differ from the one below. Initial Configuration 2020-04-07 19:33:28 DEBUG demo.py:59 root Prepare 2020-04-07 19:33:28 DEBUG demo.py:23 root Bump version 2020-04-07 19:33:28 DEBUG demo.py:25 root Generate configuration 2020-04-07 19:33:28 DEBUG demo.py:13 root Collecting parameters 2020-04-07 19:33:28 DEBUG demo.py:14 root Ask for confirmation 2020-04-07 19:33:28 INFO demo.py:15 root Save configuration 2020-04-07 19:33:28 DEBUG demo.py:27 root Select target 2020-04-07 19:33:28 WARNING demo.py:19 root Default target selected 2020-04-07 19:33:28 INFO demo.py:61 root Build executable 2020-04-07 19:33:28 DEBUG demo.py:32 root Preprocess sources 2020-04-07 19:33:28 INFO demo.py:33 root Compile sources 2020-04-07 19:33:28 INFO demo.py:37 root Link objects 2020-04-07 19:33:28 INFO demo.py:63 root Build package 2020-04-07 19:33:28 WARNING demo.py:48 root Symbols will be removed 2020-04-07 19:33:28 DEBUG demo.py:49 root Strip binary 2020-04-07 19:33:28 DEBUG demo.py:50 root Add meta data 2020-04-07 19:33:28 DEBUG demo.py:51 root Create archive 2020-04-07 19:33:28 INFO demo.py:65 root Upload package Indenting Added 2020-04-07 19:33:28 DEBUG demo.py:59 root Prepare 2020-04-07 19:33:28 DEBUG demo.py:23 root Bump version 2020-04-07 19:33:28 DEBUG demo.py:25 root Generate configuration 2020-04-07 19:33:28 DEBUG demo.py:13 root Collecting parameters 2020-04-07 19:33:28 DEBUG demo.py:14 root Ask for confirmation 2020-04-07 19:33:28 INFO demo.py:15 root Save configuration 2020-04-07 19:33:28 DEBUG demo.py:27 root Select target 2020-04-07 19:33:28 WARNING demo.py:19 root Default target selected 2020-04-07 19:33:28 INFO demo.py:61 root Build executable 2020-04-07 19:33:28 DEBUG demo.py:32 root Preprocess sources 2020-04-07 19:33:28 INFO demo.py:33 root Compile sources 2020-04-07 19:33:28 INFO demo.py:37 root Link objects 2020-04-07 19:33:28 INFO demo.py:63 root Build package 2020-04-07 19:33:28 WARNING demo.py:48 root Symbols will be removed 2020-04-07 19:33:28 DEBUG demo.py:49 root Strip binary 2020-04-07 19:33:28 DEBUG demo.py:50 root Add meta data 2020-04-07 19:33:28 DEBUG demo.py:51 root Create archive 2020-04-07 19:33:28 INFO demo.py:65 root Upload package Coloring Added 2020-04-07 19:33:28 DEBUG demo.py:59 root Prepare 2020-04-07 19:33:28 DEBUG demo.py:23 root Bump version 2020-04-07 19:33:28 DEBUG demo.py:25 root Generate configuration 2020-04-07 19:33:28 DEBUG demo.py:13 root Collecting parameters 2020-04-07 19:33:28 DEBUG demo.py:14 root Ask for confirmation 2020-04-07 19:33:28 INFO demo.py:15 root Save configuration 2020-04-07 19:33:28 DEBUG demo.py:27 root Select target 2020-04-07 19:33:28 WARNING demo.py:19 root Default target selected 2020-04-07 19:33:28 INFO demo.py:61 root Build executable 2020-04-07 19:33:28 DEBUG demo.py:32 root Preprocess sources 2020-04-07 19:33:28 INFO demo.py:33 root Compile sources 2020-04-07 19:33:28 INFO demo.py:37 root Link objects 2020-04-07 19:33:28 INFO demo.py:63 root Build package 2020-04-07 19:33:28 WARNING demo.py:48 root Symbols will be removed 2020-04-07 19:33:28 DEBUG demo.py:49 root Strip binary 2020-04-07 19:33:28 DEBUG demo.py:50 root Add meta data 2020-04-07 19:33:28 DEBUG demo.py:51 root Create archive 2020-04-07 19:33:28 INFO demo.py:65 root Upload package indentedlogs determines indentation using indentation level, which is a measure of displacement. Followin rules apply while makeing indentations: Indentation level of the first message is always 0. Indentation level is calculated incrementaly from the relative position in the call stack. Methods/functions used for logging (by default all the methods of logging.Logger class) are discarded in the call stack. Indentation level can increase at most by 1 and decrease by any value between subsequent messages. Indentation level is rounded up to the nearest integer. Indentation level is coerced to 0.. max_level range. Coercing from above the rane is indicated by special characters (by default .. ). In order to see how the algorithm works, let's change logging level from DEBUG to INFO . Initial Configuration 2020-04-07 19:33:28 INFO demo.py:15 root Save configuration 2020-04-07 19:33:28 WARNING demo.py:19 root Default target selected 2020-04-07 19:33:28 INFO demo.py:61 root Build executable 2020-04-07 19:33:28 INFO demo.py:33 root Compile sources 2020-04-07 19:33:28 INFO demo.py:37 root Link objects 2020-04-07 19:33:28 INFO demo.py:63 root Build package 2020-04-07 19:33:28 WARNING demo.py:48 root Symbols will be removed 2020-04-07 19:33:28 INFO demo.py:65 root Upload package Indenting Added 2020-04-07 19:33:28 INFO demo.py:15 root Save configuration 2020-04-07 19:33:28 WARNING demo.py:19 root Default target selected 2020-04-07 19:33:28 INFO demo.py:61 root Build executable 2020-04-07 19:33:28 INFO demo.py:33 root Compile sources 2020-04-07 19:33:28 INFO demo.py:37 root Link objects 2020-04-07 19:33:28 INFO demo.py:63 root Build package 2020-04-07 19:33:28 WARNING demo.py:48 root Symbols will be removed 2020-04-07 19:33:28 INFO demo.py:65 root Upload package Coloring Added 2020-04-07 19:33:28 INFO demo.py:15 root Save configuration 2020-04-07 19:33:28 WARNING demo.py:19 root Default target selected 2020-04-07 19:33:28 INFO demo.py:61 root Build executable 2020-04-07 19:33:28 INFO demo.py:33 root Compile sources 2020-04-07 19:33:28 INFO demo.py:37 root Link objects 2020-04-07 19:33:28 INFO demo.py:63 root Build package 2020-04-07 19:33:28 WARNING demo.py:48 root Symbols will be removed 2020-04-07 19:33:28 INFO demo.py:65 root Upload package Please check API documentation for the details on how to fine-tune the algorithm.","title":"Overview"},{"location":"#indentedlogs","text":"This library attempts to turn your logs into more readable form by addind indentation to the messages according to their location in the call stack. It also works well in conjunction with coloredlogs . Let's see how these two libraries cooperate. As an example we will use demo.py script. demo.py def bump_version (): pass def configure (): log . debug ( f \"Collecting parameters\" ) log . debug ( f \"Ask for confirmation\" ) log . info ( f \"Save configuration\" ) def select_target (): log . warning ( f \"Default target selected\" ) def prepare (): log . debug ( f \"Bump version\" ) bump_version () log . debug ( f \"Generate configuration\" ) configure () log . debug ( f \"Select target\" ) select_target () def call_compiler (): log . debug ( f \"Preprocess sources\" ) log . info ( f \"Compile sources\" ) def call_linker (): log . info ( f \"Link objects\" ) def build_executable (): # Note that callables that don't invoke logging # don't create additional indentation call_compiler () call_linker () def build_package (): log . warning ( f \"Symbols will be removed\" ) log . debug ( f \"Strip binary\" ) log . debug ( f \"Add meta data\" ) log . debug ( f \"Create archive\" ) def upload_package (): pass def release_app (): log . debug ( f \"Prepare\" ) prepare () log . info ( f \"Build executable\" ) build_executable () log . info ( f \"Build package\" ) build_package () log . info ( f \"Upload package\" ) upload_package () release_app () In order to make the script work, we need to obtain an instance of the logger and apply basic configuration. In the next step we will add indenting and coloring as demonstrated below. Initial Configuration import logging fmt = ' {asctime} {levelname:<8} {filename:>3} : {lineno:<3} {name:>10} {message} ' datefmt = '%Y-%m- %d %H:%M:%S' logging . basicConfig ( level = 'DEBUG' , format = fmt , datefmt = datefmt , style = '{' ) log = logging . getLogger () Indenting Added import logging import indentedlogs fmt = ' {asctime} {levelname:<8} {filename:>3} : {lineno:<3} {name:>10} {message} ' datefmt = '%Y-%m- %d %H:%M:%S' logging . basicConfig ( level = 'DEBUG' , format = fmt , datefmt = datefmt , style = '{' ) indentedlogs . install () log = logging . getLogger () Coloring Added import logging import indentedlogs import coloredlogs fmt = ' {asctime} {levelname:<8} {filename:>3} : {lineno:<3} {name:>10} {message} ' coloredlogs . install ( level = 'DEBUG' , fmt = fmt , style = '{' ) indentedlogs . install () # must be called after coloredlogs log = logging . getLogger () Finally we can run three versions of the script and compare the results. Note that the actual color palette may differ from the one below. Initial Configuration 2020-04-07 19:33:28 DEBUG demo.py:59 root Prepare 2020-04-07 19:33:28 DEBUG demo.py:23 root Bump version 2020-04-07 19:33:28 DEBUG demo.py:25 root Generate configuration 2020-04-07 19:33:28 DEBUG demo.py:13 root Collecting parameters 2020-04-07 19:33:28 DEBUG demo.py:14 root Ask for confirmation 2020-04-07 19:33:28 INFO demo.py:15 root Save configuration 2020-04-07 19:33:28 DEBUG demo.py:27 root Select target 2020-04-07 19:33:28 WARNING demo.py:19 root Default target selected 2020-04-07 19:33:28 INFO demo.py:61 root Build executable 2020-04-07 19:33:28 DEBUG demo.py:32 root Preprocess sources 2020-04-07 19:33:28 INFO demo.py:33 root Compile sources 2020-04-07 19:33:28 INFO demo.py:37 root Link objects 2020-04-07 19:33:28 INFO demo.py:63 root Build package 2020-04-07 19:33:28 WARNING demo.py:48 root Symbols will be removed 2020-04-07 19:33:28 DEBUG demo.py:49 root Strip binary 2020-04-07 19:33:28 DEBUG demo.py:50 root Add meta data 2020-04-07 19:33:28 DEBUG demo.py:51 root Create archive 2020-04-07 19:33:28 INFO demo.py:65 root Upload package Indenting Added 2020-04-07 19:33:28 DEBUG demo.py:59 root Prepare 2020-04-07 19:33:28 DEBUG demo.py:23 root Bump version 2020-04-07 19:33:28 DEBUG demo.py:25 root Generate configuration 2020-04-07 19:33:28 DEBUG demo.py:13 root Collecting parameters 2020-04-07 19:33:28 DEBUG demo.py:14 root Ask for confirmation 2020-04-07 19:33:28 INFO demo.py:15 root Save configuration 2020-04-07 19:33:28 DEBUG demo.py:27 root Select target 2020-04-07 19:33:28 WARNING demo.py:19 root Default target selected 2020-04-07 19:33:28 INFO demo.py:61 root Build executable 2020-04-07 19:33:28 DEBUG demo.py:32 root Preprocess sources 2020-04-07 19:33:28 INFO demo.py:33 root Compile sources 2020-04-07 19:33:28 INFO demo.py:37 root Link objects 2020-04-07 19:33:28 INFO demo.py:63 root Build package 2020-04-07 19:33:28 WARNING demo.py:48 root Symbols will be removed 2020-04-07 19:33:28 DEBUG demo.py:49 root Strip binary 2020-04-07 19:33:28 DEBUG demo.py:50 root Add meta data 2020-04-07 19:33:28 DEBUG demo.py:51 root Create archive 2020-04-07 19:33:28 INFO demo.py:65 root Upload package Coloring Added 2020-04-07 19:33:28 DEBUG demo.py:59 root Prepare 2020-04-07 19:33:28 DEBUG demo.py:23 root Bump version 2020-04-07 19:33:28 DEBUG demo.py:25 root Generate configuration 2020-04-07 19:33:28 DEBUG demo.py:13 root Collecting parameters 2020-04-07 19:33:28 DEBUG demo.py:14 root Ask for confirmation 2020-04-07 19:33:28 INFO demo.py:15 root Save configuration 2020-04-07 19:33:28 DEBUG demo.py:27 root Select target 2020-04-07 19:33:28 WARNING demo.py:19 root Default target selected 2020-04-07 19:33:28 INFO demo.py:61 root Build executable 2020-04-07 19:33:28 DEBUG demo.py:32 root Preprocess sources 2020-04-07 19:33:28 INFO demo.py:33 root Compile sources 2020-04-07 19:33:28 INFO demo.py:37 root Link objects 2020-04-07 19:33:28 INFO demo.py:63 root Build package 2020-04-07 19:33:28 WARNING demo.py:48 root Symbols will be removed 2020-04-07 19:33:28 DEBUG demo.py:49 root Strip binary 2020-04-07 19:33:28 DEBUG demo.py:50 root Add meta data 2020-04-07 19:33:28 DEBUG demo.py:51 root Create archive 2020-04-07 19:33:28 INFO demo.py:65 root Upload package indentedlogs determines indentation using indentation level, which is a measure of displacement. Followin rules apply while makeing indentations: Indentation level of the first message is always 0. Indentation level is calculated incrementaly from the relative position in the call stack. Methods/functions used for logging (by default all the methods of logging.Logger class) are discarded in the call stack. Indentation level can increase at most by 1 and decrease by any value between subsequent messages. Indentation level is rounded up to the nearest integer. Indentation level is coerced to 0.. max_level range. Coercing from above the rane is indicated by special characters (by default .. ). In order to see how the algorithm works, let's change logging level from DEBUG to INFO . Initial Configuration 2020-04-07 19:33:28 INFO demo.py:15 root Save configuration 2020-04-07 19:33:28 WARNING demo.py:19 root Default target selected 2020-04-07 19:33:28 INFO demo.py:61 root Build executable 2020-04-07 19:33:28 INFO demo.py:33 root Compile sources 2020-04-07 19:33:28 INFO demo.py:37 root Link objects 2020-04-07 19:33:28 INFO demo.py:63 root Build package 2020-04-07 19:33:28 WARNING demo.py:48 root Symbols will be removed 2020-04-07 19:33:28 INFO demo.py:65 root Upload package Indenting Added 2020-04-07 19:33:28 INFO demo.py:15 root Save configuration 2020-04-07 19:33:28 WARNING demo.py:19 root Default target selected 2020-04-07 19:33:28 INFO demo.py:61 root Build executable 2020-04-07 19:33:28 INFO demo.py:33 root Compile sources 2020-04-07 19:33:28 INFO demo.py:37 root Link objects 2020-04-07 19:33:28 INFO demo.py:63 root Build package 2020-04-07 19:33:28 WARNING demo.py:48 root Symbols will be removed 2020-04-07 19:33:28 INFO demo.py:65 root Upload package Coloring Added 2020-04-07 19:33:28 INFO demo.py:15 root Save configuration 2020-04-07 19:33:28 WARNING demo.py:19 root Default target selected 2020-04-07 19:33:28 INFO demo.py:61 root Build executable 2020-04-07 19:33:28 INFO demo.py:33 root Compile sources 2020-04-07 19:33:28 INFO demo.py:37 root Link objects 2020-04-07 19:33:28 INFO demo.py:63 root Build package 2020-04-07 19:33:28 WARNING demo.py:48 root Symbols will be removed 2020-04-07 19:33:28 INFO demo.py:65 root Upload package Please check API documentation for the details on how to fine-tune the algorithm.","title":"indentedlogs"},{"location":"api/","text":"API \u00b6 install ( indentation = ' ' , deepest_indentation = '..' , max_level = 5 , handlers = None , logger = None , logging_classes = ( logging . Logger ,), logging_functions = ()) \u00b6 Wraps formatters of each handler of the logger with the special IndentingFormatter . If logger is None (default), root logger will be used. If logger doesn't have any handlers added, an instance of logging.StreamHandler will be created and added. Handlers to be wrapped can be also provided through handlers argument. In this case loigger argument is not taken into consideration. If your application writes logs by calling custom logging functions, these functions should be registered in logging_functions . Alternatively, if they are methods of a class, this class can be registered in logging_classes . There is no need of registering classes that derive from logging.Logger . Indentation is created as indentation * indentation_level , where indentation_level is calculated from current location in the call stack. indentation_level can be limited by max_level , or unlimited when max_level is None . Whenever indentation_level exceeds the limit, indentation is created as indentation * (max_level - 1) + deepest_indentation . Parameters: Name Type Description Default indentation str String concatenated with the message to create a single-level indentation. ' ' deepest_indentation str String preceeding the message in case when indentation level exceeds the limit. '..' max_level Optional[int] Limit of the indentation level. Use None for disabling the limit. 5 handlers Optional[Iterable[logging.Handler]] Logging handlers, formatters of which are wrapped by IndentingFormatter . None logger Optional[logging.Logger] Logger, handlers of which are explored to have their formatters wrapped. None logging_classes Iterable[Type] Collection of classes, methods of which are considered as logging functions. (logging.Logger,) logging_functions Iterable[Callable] Collection of logging functions. () Source code in indentedlogs/formatters.py 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 def install ( indentation : str = ' ' , deepest_indentation : str = '..' , max_level : Optional [ int ] = 5 , handlers : Optional [ Iterable [ logging . Handler ]] = None , logger : Optional [ logging . Logger ] = None , logging_classes : Iterable [ Type ] = DefaultLogger (), logging_functions : Iterable [ Callable ] = () ) -> None : \"\"\"Wraps formatters of each handler of the `logger` with the special `IndentingFormatter`. If `logger` is `None` (default), root logger will be used. If `logger` doesn't have any handlers added, an instance of `logging.StreamHandler` will be created and added. Handlers to be wrapped can be also provided through `handlers` argument. In this case `loigger` argument is not taken into consideration. If your application writes logs by calling custom logging functions, these functions should be registered in `logging_functions`. Alternatively, if they are methods of a class, this class can be registered in `logging_classes`. There is no need of registering classes that derive from `logging.Logger`. Indentation is created as `indentation * indentation_level`, where `indentation_level` is calculated from current location in the call stack. `indentation_level` can be limited by `max_level`, or unlimited when `max_level` is `None`. Whenever `indentation_level` exceeds the limit, indentation is created as `indentation * (max_level - 1) + deepest_indentation`. Arguments: indentation: String concatenated with the message to create a single-level indentation. deepest_indentation: String preceeding the message in case when indentation level exceeds the limit. max_level: Limit of the indentation level. Use `None` for disabling the limit. handlers: Logging handlers, formatters of which are wrapped by `IndentingFormatter`. logger: Logger, handlers of which are explored to have their formatters wrapped. logging_classes: Collection of classes, methods of which are considered as logging functions. logging_functions: Collection of logging functions. \"\"\" if isinstance ( logging_classes , DefaultLogger ): logging_classes = DefaultLogger . value monitor = StackMonitor ( logging_classes , logging_functions ) if handlers is None : if logger is None : logger = logging . getLogger () if not logger . handlers : # Default handler (`logging.lastResort`) could be used here, # but it is not part of the official API logger . addHandler ( logging . StreamHandler ()) handlers = logger . handlers for handler in handlers : ind_fmt = IndentingFormatter ( monitor , indentation , deepest_indentation , max_level ) if handler . formatter is None : handler . setFormatter ( ind_fmt ) else : stk_fmt = StackedFormatter ( handler . formatter , ind_fmt ) handler . setFormatter ( stk_fmt )","title":"API"},{"location":"api/#api","text":"","title":"API"},{"location":"api/#indentedlogs.formatters.install","text":"Wraps formatters of each handler of the logger with the special IndentingFormatter . If logger is None (default), root logger will be used. If logger doesn't have any handlers added, an instance of logging.StreamHandler will be created and added. Handlers to be wrapped can be also provided through handlers argument. In this case loigger argument is not taken into consideration. If your application writes logs by calling custom logging functions, these functions should be registered in logging_functions . Alternatively, if they are methods of a class, this class can be registered in logging_classes . There is no need of registering classes that derive from logging.Logger . Indentation is created as indentation * indentation_level , where indentation_level is calculated from current location in the call stack. indentation_level can be limited by max_level , or unlimited when max_level is None . Whenever indentation_level exceeds the limit, indentation is created as indentation * (max_level - 1) + deepest_indentation . Parameters: Name Type Description Default indentation str String concatenated with the message to create a single-level indentation. ' ' deepest_indentation str String preceeding the message in case when indentation level exceeds the limit. '..' max_level Optional[int] Limit of the indentation level. Use None for disabling the limit. 5 handlers Optional[Iterable[logging.Handler]] Logging handlers, formatters of which are wrapped by IndentingFormatter . None logger Optional[logging.Logger] Logger, handlers of which are explored to have their formatters wrapped. None logging_classes Iterable[Type] Collection of classes, methods of which are considered as logging functions. (logging.Logger,) logging_functions Iterable[Callable] Collection of logging functions. () Source code in indentedlogs/formatters.py 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 def install ( indentation : str = ' ' , deepest_indentation : str = '..' , max_level : Optional [ int ] = 5 , handlers : Optional [ Iterable [ logging . Handler ]] = None , logger : Optional [ logging . Logger ] = None , logging_classes : Iterable [ Type ] = DefaultLogger (), logging_functions : Iterable [ Callable ] = () ) -> None : \"\"\"Wraps formatters of each handler of the `logger` with the special `IndentingFormatter`. If `logger` is `None` (default), root logger will be used. If `logger` doesn't have any handlers added, an instance of `logging.StreamHandler` will be created and added. Handlers to be wrapped can be also provided through `handlers` argument. In this case `loigger` argument is not taken into consideration. If your application writes logs by calling custom logging functions, these functions should be registered in `logging_functions`. Alternatively, if they are methods of a class, this class can be registered in `logging_classes`. There is no need of registering classes that derive from `logging.Logger`. Indentation is created as `indentation * indentation_level`, where `indentation_level` is calculated from current location in the call stack. `indentation_level` can be limited by `max_level`, or unlimited when `max_level` is `None`. Whenever `indentation_level` exceeds the limit, indentation is created as `indentation * (max_level - 1) + deepest_indentation`. Arguments: indentation: String concatenated with the message to create a single-level indentation. deepest_indentation: String preceeding the message in case when indentation level exceeds the limit. max_level: Limit of the indentation level. Use `None` for disabling the limit. handlers: Logging handlers, formatters of which are wrapped by `IndentingFormatter`. logger: Logger, handlers of which are explored to have their formatters wrapped. logging_classes: Collection of classes, methods of which are considered as logging functions. logging_functions: Collection of logging functions. \"\"\" if isinstance ( logging_classes , DefaultLogger ): logging_classes = DefaultLogger . value monitor = StackMonitor ( logging_classes , logging_functions ) if handlers is None : if logger is None : logger = logging . getLogger () if not logger . handlers : # Default handler (`logging.lastResort`) could be used here, # but it is not part of the official API logger . addHandler ( logging . StreamHandler ()) handlers = logger . handlers for handler in handlers : ind_fmt = IndentingFormatter ( monitor , indentation , deepest_indentation , max_level ) if handler . formatter is None : handler . setFormatter ( ind_fmt ) else : stk_fmt = StackedFormatter ( handler . formatter , ind_fmt ) handler . setFormatter ( stk_fmt )","title":"install()"}]}